import { NodeProc, NodePhi, ControlSource, ControlSink, ControlFlow, Graph, SymbolSource, SymbolSink, DataFlow } from "./graph";
import { setIsEqual, setIsSubset, setExcept, error } from "./helpers";
import { ProcDefinitions, GraphProblem, SymbolInstance } from "./graph-context";
import { getSymbolSourceType, getSymbolSinkType, getSymbolSourceOf } from "./graph-analysis";
import { typeEquals } from "./type";

export function validateSymbolLink(graph: Graph, procs: ProcDefinitions, src: SymbolSource, sink: SymbolSink, onProblem: (problem: GraphProblem) => void): void {
  const sourceType = getSymbolSourceType(graph, procs, src);
  const sinkType = getSymbolSinkType(graph, procs, sink);
  if (sourceType === undefined) {
    onProblem({ severity: "error", message: `Symbol source of input '${sink.id}' not found.`, graphComponent: sink.target, needsHumanIntervention: true });
    return;
  }
  if (sinkType === undefined) {
    return error("invalid symbol sink (generated by this program...)");
  }
  if (!typeEquals(sourceType, sinkType))
    onProblem({ severity: "error", message: `Symbol source of input '${sink.id}' has type conflicting type.`, graphComponent: sink.target, needsHumanIntervention: true });
}

export function validateNodePhi(n: NodePhi, onProblem: (problem: GraphProblem) => void): void {

}

export function validateNodeProc(n: NodeProc, procs: ProcDefinitions, onProblem: (problem: GraphProblem) => void): void {
  // proc exists
  const id = n.procID;
  const proc = procs[id];
  if (proc === undefined) {
    onProblem({ severity: "error", message: `Procedure '${id}' not found.`, graphComponent: n, needsHumanIntervention: true });
    return;
  }
  // inputs expected by proc match inputs given
  const demand = Object.keys(proc.inputs);
  const supply = Object.keys(n.inputs);
  for (const x of setExcept(demand, supply))
    onProblem({ severity: "error", message: `Procedure '${id}' requires input '${x}'.`, graphComponent: n, needsHumanIntervention: false });
  for (const x of setExcept(supply, demand))
    onProblem({ severity: "warning", message: `Procedure '${id}' does not know input '${x}'.`, graphComponent: n, needsHumanIntervention: false });
}

export function validateRawControlFlow(rawEdges: ReadonlyArray<ControlFlow>, controlSourceNorm: (x: ControlSource) => ControlSource | undefined, controlSinkNorm: (x: ControlSink) => ControlSink | undefined, onProblem: (p: GraphProblem) => void): void {
  // edges point to existing sources and sinks?
  for (const edge of rawEdges) {
    if (controlSourceNorm(edge.source) === undefined)
      onProblem({ severity: "error", message: `Source of control flow edge does not exist.`, graphComponent: edge, needsHumanIntervention: true });
    if (controlSinkNorm(edge.target) === undefined)
      onProblem({ severity: "error", message: `Sink of control flow edge does not exist.`, graphComponent: edge, needsHumanIntervention: true });
  }
}

export function validateControlFlow(edges: ReadonlyArray<ControlFlow>, controlSources: Iterable<ControlSource>, controlSinks: Iterable<ControlSink>, onProblem: (p: GraphProblem) => void): void {
  // number of connections
  for (const x of controlSources) {
    const adjacent = edges.filter(f => f.source === x).length;
    if (adjacent > 1) onProblem({ severity: "error", message: `More than one outgoing control flow.`, graphComponent: x, needsHumanIntervention: true });
    if (adjacent < 1) onProblem({ severity: "error", message: `No outgoing control flow.`, graphComponent: x, needsHumanIntervention: false });
  }
  for (const x of controlSinks) {
    const adjacent = edges.filter(f => f.target === x).length;
    if (adjacent > 1) onProblem({ severity: "error", message: `More than one incoming control flow.`, graphComponent: x, needsHumanIntervention: false });
    if (adjacent < 1) onProblem({ severity: "warning", message: `No incoming control flow.`, graphComponent: x, needsHumanIntervention: false });
  }
}

export function validateRawDataFlow(graph: Graph, procs: ProcDefinitions, symbolSinks: Iterable<SymbolSink>, symbolSourceNorm: (x: SymbolSource) => SymbolSource | undefined, onProblem: (p: GraphProblem) => void): void {
  // symbol source exists?
  for (const sink of symbolSinks) {
    let src = getSymbolSourceOf(graph, procs, sink);
    if (src === undefined) onProblem({ severity: "error", message: `Symbol sink '${sink.id}' unconnected.`, graphComponent: sink.target, needsHumanIntervention: false });
    else {
      src = symbolSourceNorm(src);
      if (src === undefined) onProblem({ severity: "error", message: `Symbol source of '${sink.id}' does not exist.`, graphComponent: sink.target, needsHumanIntervention: true });
    }
  }
}

export function validateDataFlow(graph: Graph, procs: ProcDefinitions, edges: ReadonlyArray<DataFlow>, onProblem: (p: GraphProblem) => void): void {
  for (const edge of edges)
    validateSymbolLink(graph, procs, edge.source, edge.target, onProblem);
}

export function validateSymbolAvailability(edges: Iterable<ControlFlow>, supply: ReadonlyMap<ControlSource, ReadonlySet<SymbolInstance>>, demand: ReadonlyMap<ControlSink, ReadonlySet<SymbolInstance>>, onProblem: (p: GraphProblem) => void): void {
  for (const edge of edges) {
    const a = supply.get(edge.source);
    const b = demand.get(edge.target);
    if (a === undefined || b === undefined) return error("supply/demand incomplete");
    const except = [...setExcept(b, a)];
    if (except.length !== 0)
      onProblem({ severity: "error", message: `Symbols '${except.map(x => x.source.id).join(', ')}' not available.`, graphComponent: edge.target, needsHumanIntervention: false });
  }
}